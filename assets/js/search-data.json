{
  
    
        "post0": {
            "title": "John Conways' game of life in python",
            "content": "Introduction . . This small project represents the python Implementation of John Conways’ game of life, if you don’t know what I’m talking about stick with me, I’ll explain everything from idea to implementation. . Project repo: Game Of Life . What is the game of life . According to Wikipedia the game of life is in simple terms a game that mimics the behavior and lifecycle of biological cells in nature following 4 simple rules: . Any live cell with fewer than two live neighbours dies, as if by underpopulation. | Any live cell with two or three live neighbours lives on to the next generation. | Any live cell with more than three live neighbours dies, as if by overpopulation. | Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction. | Out of these simple rules we can create starting configurations that lead to complex systems and shapes like oscillators, spaceships and even turing machines . Motivation . I was glad that I stumbled upon a great talk on youtube called The Art of Code which I highly recommend watching it. Dylan Beattie is a programmer and musician talked about different beautiful artistic moments of coding and what coders have achieved from writing mesmerizing quines to coming up with weird but funny programming languages like Rockstar programming language but what has really caught my attention is talking about the game of life which made my jaw drop and let me think very deeply about its capabilities. At this moment I knew nothing about it and suddenly had the urge to implement it in my favourite programming language (python) . Implementation . Engine . At this point I have no idea how to implement this graphically so I started first by creating a Grid class which represents our infinte 2d space. This grid is in fact a 2d array which translates to a nested list in python. our grid of length w and width h is initialized by w*h zeros when called. . . N.B: 0 means that the cell is dead and 1 is alive class Grid: . import random class Grid(list): def __init__(self, w, h): &quot;&quot;&quot; initializes a grid of zeros with length w and width h &quot;&quot;&quot; self.w = w self.h = h super() for row in range(w): # Add an empty array that will hold each cell # in this row self.append([]) for column in range(h): self[row].append(0) # Append a cell def show(self): for row in range(self.w): ch=&#39;[&#39; for col in range(self.h): ch += str(self[row][col])+&#39;,&#39; if col == self.h-1: ch=ch[:-1]+&#39;]&#39; print(ch,&#39; n&#39;) . Example: . grid = Grid(5,5) grid.show() . Output: . [0,0,0] . [0,0,0] . [0,0,0] . Now that we have defined and created our data structure the next task is to define a function to calculate the number of alive neighbors for each cell of position x,y by visiting its next eight neighbors and summing up their values. . def alive_neighbors(self,x,y): &quot;&quot;&quot; returns the number of alive neighbors (=1) for a certain x,y position &quot;&quot;&quot; res = 0 for row in range(x-1,x+2): for col in range(y-1,y+2): if (row==x) and (col==y): continue try: if self[row][col] == 1: res+=1 pass except IndexError:#If this error is raised for cells on the edges we consider the next edge cells are the neighbors, like we are wrapping a sheet of paper so the edges touch row = (x+row+self.w)%self.w col = (y+col+self.h)%self.h return res . Example: . [0,1,0] . [0,0,0] . [1,1,1] . neighbors = grid.alive_neighbors(1,1) # cell in position 1,1 print(neighbors) . Output: 4 which is the sum of neighbor alive cells . Before thinking about gui we have to try it on terminal and see if everything works fine. We start by making a grid and choose starting configuration, get each cell’s state and update it in next_grid, after looping through all cells we print the updated version (next_grid) and each loop through the grid represnts a new generation of cells. . test.py . from grid import Grid grid = Grid(3,5) grid[1][1] = 1 grid[1][2] = 1 grid[1][3] = 1 if __name__ == &#39;__main__&#39;: grid.show() next_grid = Grid(3,5) for row in range(3): for col in range(5): state = grid[row][col] #get every element&#39;s neighbors of grid neighbors = grid.alive_neighbors(row,col) if neighbors == 3 and state ==0 :# These are the first 3 rules stated above next_grid[row][col] = 1 elif (neighbors&lt;2 or neighbors&gt;3) and state ==1 : # This is the last rule of game of life next_grid[row][col] = 0 else: next_grid[row][col] = state print(&#39;=&#39;*10) next_grid.show() grid = next_grid . Output: this is the representation of an oscillator . [0,0,0,0,0] ===&gt; [0,0,1,0,0] . [0,1,1,1,0] ===&gt; [0,0,1,0,0] . [0,0,0,0,0] ===&gt; [0,0,1,0,0] . Interface . For the gui I decided to use pygame for its simplicity and powerful functionalities, we start by defining some global variables. . # Define some colors BLACK = (0, 0, 0) WHITE = (255, 255, 255) GREEN = (0, 255, 0) RED = (255, 0, 0) # This sets the WIDTH and HEIGHT of each grid location SQUARE = 20 # This sets the margin between each cell MARGIN = 2 #Screen resolution w = 700 h = 500 #calculate row_num, col_num from current resolution row_num = w//SQUARE col_num = h//SQUARE . Next define the draw method which represents our grid of zeros and ones by graphical squares of white color if dead and green color if alive: . #def initialize grid def draw_grid(row_num, col_num, g): # Draw the grid for row in range(row_num): for column in range(col_num): color = WHITE pygame.draw.rect(screen, color, [(MARGIN + SQUARE) * row + MARGIN, (MARGIN + SQUARE) * column + MARGIN, SQUARE, SQUARE]) if g[row][column] == 1: pygame.draw.rect(screen, GREEN, [(MARGIN + SQUARE) * row + MARGIN, (MARGIN + SQUARE) * column + MARGIN, SQUARE, SQUARE]) pygame.display.flip() . Then we have to create a window of size w,h and draw initial grid . def create_window(w, h): # Set the HEIGHT and WIDTH of the screen screen = pygame.display.set_mode([w,h]) # Set title of screen pygame.display.set_caption(&quot;John Conway&#39;s game of life&quot;) return screen #create window of size 700px by 500px screen = create_window(w, h) #draw initial grid draw_grid(row_num, col_num, grid) . The final step is defining the main loop to keep the game running and see some magic patterns, once we press the space key we apply the same rules on the grid like we did on the first prototype of the game and draw each new generation of cells to the screen of our window. . # -- Main Program Loop -- while not done: for event in pygame.event.get(): # User did something if event.type == pygame.QUIT: # If user clicked close done = True # Flag that we are done so we exit this loop elif event.type == pygame.KEYDOWN: # Game starts if event.key == K_SPACE: print(&#39;space key pressed&#39;) x = 0 while True: next_grid = Grid(row_num, col_num) for row in range(row_num): for col in range(col_num): state = grid[row][col]#current grid state 0 or 1 neighbors = grid.alive_neighbors(row,col)#current grid alive neighbors if state == 1 and (neighbors&lt;2 or neighbors&gt;3): next_grid[row][col] = 0 elif state == 0 and neighbors == 3: next_grid[row][col] = 1 else: next_grid[row][col] = state draw_grid(row_num, col_num, next_grid) grid = next_grid x+=1 print(&#39;generation:&#39;,x) # Limit to x frames per second clock.tick(x) # Be IDLE friendly. If you forget this line, the program will &#39;hang&#39; # on exit. pygame.quit() . Final Result of a random config: . . Conclusion . I had so fun working on this project and I hope it helps you because at first place I did not find a good python implementation of this project. . Next Steps: . Add drawing functionality by mouse, so you can choose easily the starting config (done) | I think of optimizing the game by using numpy instead of grid (done) | Make an interactive web app of it using flask and deploy it | . Go back up .",
            "url": "/Blog/programming/2020/03/21/gameoflife.html",
            "relUrl": "/programming/2020/03/21/gameoflife.html",
            "date": " • Mar 21, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Fares Lassoued, 23 yo from Tunisia. I’m a cs graduate with interest in Data science, so I’m teaching myself to be a better coder, data scientist and a good problem solver! . You can find me on: . Linekedin | Github | Kaggle | Quora | .",
          "url": "/Blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Projects",
          "content": "Project Description Link(s) Category . A/B test for e-commerce company | Perform A/B test and analyze results to help a company decide between a new developed pageand an old one for their e-commerce website. | - repo | data analysis, a/b testing | . Soccer database analysis | Data analysis and exploration of the european soccer database from kaggle. | - repo | data analysis | . Explore weather trends | Analyze local and global temperature data and compare the temperature trends where I live to overall global temperature trends. | - repo | data analysis | . MNIST guai | Desktop app for handwritten digit recognition using a machine learning classifier. I wanted to build on this ml project to test the classifier in real-time. | - repo | machine learning, | . Game of Life | This project represents the python Implementation of John Conway’s game of life using pygame library | - repo - blogpost | game programming | .",
          "url": "/Blog/projects/",
          "relUrl": "/projects/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

}